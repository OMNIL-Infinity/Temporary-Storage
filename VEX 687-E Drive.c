#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           ForwardLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ForwardRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           BackwardLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           BackwardRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LauncherLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LauncherRight, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           Intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Debug,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float Gain = 0.025;
const float Tolerance = 20;
short Speed;
float Input;
float Output;
float pOutput = 0;
float Error;
float pError = Input;
const float dTime = 0.05;

void Drive(int LVertical, int RVertical) {
	motor[ForwardLeft] = LVertical; 	motor[ForwardRight] = RVertical;
	motor[BackwardLeft] = LVertical;	motor[BackwardRight] = RVertical;
}

int Sensitivity(int Input, int Other) {
	if (Input * Other <= -16 * 127)
		return Input/2;
	return Input;
}

int Threshold(int Input) {
		if (abs(Input) > 16)
			return 127 * abs(Input)/Input;
		return 0;
}

float Controller(float Current) {
	Error = Input - Current;
	Output += Error * Gain;
	if (Output > 127)
		Output = 127;
	if (Output < 0)
		Output = 0;
	if (Error * pError < 0) {
		if (abs(pOutput - Output) > Tolerance)
			Output = pOutput;
		else
			Output = (pOutput + Output)/2;
	}
	pOutput = Output;
	pError = Error;
	return Output;
}

void Shoot(bool Button, float Power) {
	if (Button) {
		motor[LauncherLeft] = Power; motor[LauncherRight] = Power;
	}
	else {
		motor[LauncherLeft] = 0; motor[LauncherRight] = 0;
	}
}

int Steer(int Input, bool Direction) {
	if (Direction)
		return Input/16;
	return Input;
}

void Reload(bool Forward, bool Backward) {
	if (Forward)
		motor[Intake] = 127;
	else if (Backward)
		motor[Intake] = -127;
	else
		motor[Intake] = 0;
}

void Debugger(bool Enable) {
	motor[Debug] = 127;
}

task second() {
	Input = 0;
	while (true) {
		Input += 1;
		Input = (int) Input % 128;
		Speed = getMotorVelocity(LauncherRight);
		Output = Controller(Speed);
		wait1Msec(dTime * 1000);
	}
}

task main() {
	int LVertical = 0, RVertical = 0;
	bool Debug = true;
	startTask(second);
	Shoot(true, 10);
	wait1Msec(100);
	while (true) {
		Reload(vexRT[Btn5D], vexRT[Btn7D]);
		Shoot(vexRT[Btn6D], Output);
		if (vexRT[Btn7L])
			Debug = !Debug;
		Debugger(Debug);
		LVertical = Threshold(vexRT[Ch3]);
		RVertical = Threshold(vexRT[Ch2]);
		LVertical = Steer(LVertical, vexRT[Btn5U]);
		RVertical = Steer(RVertical, vexRT[Btn6U]);
		LVertical = Sensitivity(LVertical, RVertical);
		RVertical = Sensitivity(RVertical, LVertical);
		Drive(LVertical, RVertical);
	}
}
